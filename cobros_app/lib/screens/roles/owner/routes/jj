import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:excel/excel.dart';
import 'dart:typed_data';
import 'package:share_plus/share_plus.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:io';

class LiquidationReportScreen extends StatefulWidget {
  const LiquidationReportScreen({super.key});

  @override
  State<LiquidationReportScreen> createState() => _LiquidationReportScreenState();
}

class ColumnDefinition {
  final String key;
  final String label;
  final bool numeric;
  final Comparable Function(DocumentSnapshot) getValue;

  ColumnDefinition({
    required this.key,
    required this.label,
    required this.numeric,
    required this.getValue,
  });
}

class _LiquidationReportScreenState extends State<LiquidationReportScreen> {
  List<DocumentSnapshot> liquidations = [];
  List<DocumentSnapshot> filteredLiquidations = [];
  DateTime? startDate;
  DateTime? endDate;
  bool _isLoading = true;

  // Para el filtro por cobrador con autocompletado
  String? _selectedCollector;
  List<String> _collectors = [];

  int? _sortColumnIndex;
  bool _sortAscending = true;

  final ScrollController _horizontalScrollController = ScrollController();
  final currencyFormat = NumberFormat.currency(locale: 'es_CO', symbol: '\$');

  final int _pageSize = 20;
  DocumentSnapshot? _lastDocument;
  bool _hasMore = true;
  bool _isLoadingMore = false;

  Future<void> _fetchLiquidations() async {
    setState(() => _isLoading = true);
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      setState(() => _isLoading = false);
      return;
    }

    try {
      final userDoc = await FirebaseFirestore.instance.collection('users').doc(user.uid).get();
      final userData = userDoc.data();
      if (userData == null || userData['officeId'] == null) {
        setState(() => _isLoading = false);
        return;
      }

      final userOfficeId = userData['officeId'];

      Query query = FirebaseFirestore.instance
          .collection('liquidations')
          .where('officeId', isEqualTo: userOfficeId);

      if (startDate != null && endDate != null) {
        final start = DateTime(startDate!.year, startDate!.month, startDate!.day);
        final end = DateTime(endDate!.year, endDate!.month, endDate!.day + 1);
        query = query.where('date', isGreaterThanOrEqualTo: start).where('date', isLessThan: end);
      }

      final snapshot = await query.get();
      setState(() {
        liquidations = snapshot.docs;

        // Obtener lista de cobradores única y ordenada
        final collectorsSet = <String>{};
        for (var doc in liquidations) {
          final data = doc.data() as Map<String, dynamic>;
          final collectorName = (data['collectorName'] ?? '').toString();
          if (collectorName.isNotEmpty) collectorsSet.add(collectorName);
        }
        _collectors = collectorsSet.toList()..sort();

        _applyFilters();
        _isLoading = false;
      });
    } catch (e) {
      print('Error al obtener liquidaciones: $e');
      setState(() => _isLoading = false);
    }
  }

  void _applyFilters() {
    filteredLiquidations =
        liquidations.where((doc) {
          final data = doc.data() as Map<String, dynamic>;
          final name = (data['collectorName'] ?? '').toString();
          if (_selectedCollector == null || _selectedCollector!.isEmpty) {
            return true;
          } else {
            return name == _selectedCollector;
          }
        }).toList();
  }

  void _onSort<T>(
    Comparable<T> Function(DocumentSnapshot d) getField,
    int columnIndex,
    bool ascending,
  ) {
    filteredLiquidations.sort((a, b) {
      final aVal = getField(a);
      final bVal = getField(b);
      return ascending ? Comparable.compare(aVal, bVal) : Comparable.compare(bVal, aVal);
    });
    setState(() {
      _sortColumnIndex = columnIndex;
      _sortAscending = ascending;
    });
  }

  void _clearFilters() {
    setState(() {
      _selectedCollector = null;
      startDate = null;
      endDate = null;
    });
    _fetchLiquidations();
  }

  Future<void> _exportToExcel() async {
    final excel = Excel.createExcel();
    final sheet = excel['Reporte'];

    sheet.appendRow(['Fecha', 'Cobrador', 'Recaudado', 'Descuento', 'Neto', 'Pagos']);

    for (var doc in filteredLiquidations) {
      final data = doc.data() as Map<String, dynamic>;
      final date = (data['date'] as Timestamp).toDate();
      final payments = List.from(data['payments'] ?? []);
      sheet.appendRow([
        DateFormat('yyyy-MM-dd').format(date),
        data['collectorName'] ?? '',
        data['totalCollected'] ?? 0,
        data['discountTotal'] ?? 0,
        data['netTotal'] ?? 0,
        payments.length,
      ]);
    }

    final fileBytes = excel.encode();
    if (fileBytes == null) return;

    final directory = await getTemporaryDirectory();
    final filePath = '${directory.path}/reporte_liquidaciones.xlsx';
    final file = File(filePath);
    await file.writeAsBytes(fileBytes, flush: true);

    await Share.shareXFiles([XFile(filePath)], text: 'Reporte de Liquidaciones');
  }

  late List<ColumnDefinition> allColumns;
  Set<String> visibleColumnsKeys = {}; // Las columnas seleccionadas visibles

  @override
  void initState() {
    super.initState();
    final today = DateTime.now();
    startDate = DateTime(today.year, today.month, today.day); // inicio del día hoy
    endDate = DateTime(
      today.year,
      today.month,
      today.day,
    ); // fin del día hoy (igual, se sumará +1 en el query)
    _fetchLiquidations();

    allColumns = [
      ColumnDefinition(
        key: 'date',
        label: 'Fecha',
        numeric: false,
        getValue: (d) => (d['date'] as Timestamp).toDate(),
      ),
      ColumnDefinition(
        key: 'collectorName',
        label: 'Cobrador',
        numeric: false,
        getValue: (d) => d['collectorName'] ?? '',
      ),
      ColumnDefinition(
        key: 'totalCollected',
        label: 'Recaudado',
        numeric: true,
        getValue: (d) => d['totalCollected'] ?? 0,
      ),
      ColumnDefinition(
        key: 'discountTotal',
        label: 'Descuento',
        numeric: true,
        getValue: (d) => d['discountTotal'] ?? 0,
      ),
      ColumnDefinition(
        key: 'netTotal',
        label: 'Neto',
        numeric: true,
        getValue: (d) => d['netTotal'] ?? 0,
      ),
      ColumnDefinition(
        key: 'payments',
        label: 'Pagos',
        numeric: true,
        getValue: (d) => (d['payments'] as List).length,
      ),
    ];

    // Por defecto mostrar todas las columnas
    visibleColumnsKeys = allColumns.map((c) => c.key).toSet();
  }

  @override
  void dispose() {
    _horizontalScrollController.dispose();
    super.dispose();
  }

  void _showColumnSelectionDialog() async {
    Set<String> selectedKeys = Set<String>.from(visibleColumnsKeys);

    await showDialog(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setStateDialog) {
            return AlertDialog(
              title: const Text('Seleccionar columnas a mostrar'),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children:
                      allColumns.map((col) {
                        return CheckboxListTile(
                          value: selectedKeys.contains(col.key),
                          title: Text(col.label),
                          onChanged: (bool? value) {
                            setStateDialog(() {
                              if (value == true) {
                                selectedKeys.add(col.key);
                              } else {
                                selectedKeys.remove(col.key);
                              }
                            });
                          },
                        );
                      }).toList(),
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: const Text('Cancelar'),
                ),
                ElevatedButton(
                  onPressed: () {
                    setState(() {
                      visibleColumnsKeys = selectedKeys;
                    });
                    Navigator.of(context).pop();
                  },
                  child: const Text('Aceptar'),
                ),
              ],
            );
          },
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    double totalCollected = 0;
    double totalDiscount = 0;
    double totalNet = 0;
    int totalPayments = 0;

    final visibleColumns = allColumns.where((col) => visibleColumnsKeys.contains(col.key)).toList();

    for (var doc in filteredLiquidations) {
      final data = doc.data() as Map<String, dynamic>;
      totalCollected += (data['totalCollected'] ?? 0).toDouble();
      totalDiscount += (data['discountTotal'] ?? 0).toDouble();
      totalNet += (data['netTotal'] ?? 0).toDouble();
      totalPayments += (data['payments'] as List?)?.length ?? 0;
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Reporte de Liquidaciones'),
        actions: [
          IconButton(
            icon: const Icon(Icons.view_column),
            tooltip: 'Seleccionar columnas',
            onPressed: _showColumnSelectionDialog,
          ),
          ElevatedButton.icon(
            onPressed: () async {
              final picked = await showDateRangePicker(
                context: context,
                firstDate: DateTime(2022),
                lastDate: DateTime.now(),
              );
              if (picked != null) {
                setState(() {
                  startDate = picked.start;
                  endDate = picked.end;
                });
                _fetchLiquidations();
              }
            },
            icon: const Icon(Icons.date_range),
            label: const Text('Filtrar por fecha'),
          ),
          IconButton(icon: const Icon(Icons.clear), onPressed: _clearFilters),
          IconButton(icon: const Icon(Icons.download), onPressed: _exportToExcel),
        ],
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(120),
          child: Column(
            children: [
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                child: Autocomplete<String>(
                  optionsBuilder: (TextEditingValue textEditingValue) {
                    if (textEditingValue.text == '') {
                      return _collectors;
                    }
                    return _collectors.where(
                      (collector) =>
                          collector.toLowerCase().contains(textEditingValue.text.toLowerCase()),
                    );
                  },
                  onSelected: (String selection) {
                    setState(() {
                      _selectedCollector = selection;
                      _applyFilters();
                    });
                  },
                  fieldViewBuilder: (context, controller, focusNode, onEditingComplete) {
                    controller.text = _selectedCollector ?? '';
                    return TextField(
                      controller: controller,
                      focusNode: focusNode,
                      onEditingComplete: onEditingComplete,
                      decoration: InputDecoration(
                        hintText: 'Filtrar por cobrador...',
                        prefixIcon: const Icon(Icons.person_search),
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                        suffixIcon:
                            _selectedCollector != null
                                ? IconButton(
                                  icon: const Icon(Icons.clear),
                                  onPressed: () {
                                    setState(() {
                                      _selectedCollector = null;
                                      _applyFilters();
                                    });
                                  },
                                )
                                : null,
                      ),
                    );
                  },
                ),
              ),
              if (startDate != null && endDate != null)
                Text(
                  'Rango: ${DateFormat('yyyy-MM-dd').format(startDate!)} - ${DateFormat('yyyy-MM-dd').format(endDate!)}',
                  style: const TextStyle(fontSize: 13, fontStyle: FontStyle.italic),
                ),
              Text(
                'Mostrando ${filteredLiquidations.length} resultados',
                style: const TextStyle(fontSize: 13, fontStyle: FontStyle.italic),
              ),
              const SizedBox(height: 4),
            ],
          ),
        ),
      ),
      body:
          _isLoading
              ? const Center(child: CircularProgressIndicator())
              : filteredLiquidations.isEmpty
              ? const Center(child: Text('No hay liquidaciones registradas.'))
              : LayoutBuilder(
                builder: (context, constraints) {
                  return Center(
                    child: Container(
                      width: constraints.maxWidth * 0.98,
                      height: constraints.maxHeight * 0.85,
                      padding: const EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        borderRadius: BorderRadius.circular(12),
                        boxShadow: const [BoxShadow(color: Colors.black12, blurRadius: 6)],
                      ),
                      child: Scrollbar(
                        thumbVisibility: true,
                        controller: _horizontalScrollController,
                        child: SingleChildScrollView(
                          scrollDirection: Axis.horizontal,
                          controller: _horizontalScrollController,
                          child: ConstrainedBox(
                            constraints: const BoxConstraints(minWidth: 1000),
                            child: SingleChildScrollView(
                              scrollDirection: Axis.horizontal,
                              controller: _horizontalScrollController,
                              child: DataTable(
                                sortColumnIndex: _sortColumnIndex,
                                sortAscending: _sortAscending,
                                columns:
                                    allColumns
                                        .where((col) => visibleColumnsKeys.contains(col.key))
                                        .map(
                                          (col) => DataColumn(
                                            label: Text(col.label),
                                            numeric: col.numeric,
                                            onSort: (columnIndex, ascending) {
                                              _onSort(col.getValue, columnIndex, ascending);
                                            },
                                          ),
                                        )
                                        .toList(),
                                rows: [
                                  ...filteredLiquidations.map((doc) {
                                    return DataRow(
                                      cells:
                                          allColumns
                                              .where((col) => visibleColumnsKeys.contains(col.key))
                                              .map((col) {
                                                final value = col.getValue(doc);
                                                final displayValue =
                                                    value is DateTime
                                                        ? DateFormat('yyyy-MM-dd').format(value)
                                                        : (col.numeric && value is num
                                                            ? currencyFormat.format(value)
                                                            : value.toString());
                                                return DataCell(Text(displayValue));
                                              })
                                              .toList(),
                                    );
                                  }),
                                  DataRow(
                                    color: MaterialStateProperty.all(Colors.grey[300]),
                                    cells:
                                        visibleColumns.map((col) {
                                          String text = '';
                                          switch (col.key) {
                                            case 'totalCollected':
                                              text = currencyFormat.format(totalCollected);
                                              break;
                                            case 'discountTotal':
                                              text = currencyFormat.format(totalDiscount);
                                              break;
                                            case 'netTotal':
                                              text = currencyFormat.format(totalNet);
                                              break;
                                            case 'payments':
                                              text = totalPayments.toString();
                                              break;
                                            case 'date':
                                              text = 'Totales';
                                              break;
                                            default:
                                              text = '';
                                          }
                                          return DataCell(
                                            Text(
                                              text,
                                              style: const TextStyle(fontWeight: FontWeight.bold),
                                            ),
                                          );
                                        }).toList(),
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ),
                      ),
                    ),
                  );
                },
              ),
    );
  }
}
